# main_tg_bot/command/view_booking.py (–∏–ª–∏ –∫–∞–∫ —É –≤–∞—Å)
import os
from datetime import date
from pathlib import Path

import pandas as pd
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

from common.config import Config
from common.logging_config import setup_logger
from main_tg_bot.booking_objects import PROJECT_ROOT

logger = setup_logger("view_booking")

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ booking –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ—Ä–Ω—è –ø—Ä–æ–µ–∫—Ç–∞
BOOKING_DATA_DIR = PROJECT_ROOT / Config.BOOKING_DATA_DIR

# –ü—Ä–µ—Ñ–∏–∫—Å—ã –¥–ª—è callback
VB_CALLBACK_PREFIX = "vb_"
VB_SHEET_SELECT = f"{VB_CALLBACK_PREFIX}sheet"


def get_all_booking_files() -> list:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö .csv —Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ booking/"""
    if not BOOKING_DATA_DIR.exists():
        return []
    files = [
        f.name for f in BOOKING_DATA_DIR.iterdir()
        if f.is_file() and f.suffix == '.csv'
    ]
    return sorted(files)


def format_file_name(file_name: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Telegram"""
    name = file_name.replace('.csv', '').replace('_', ' ').title()
    return name


async def view_booking_handler(update, context):
    try:
        logger.info(f"view_booking_handler called with update type: {type(update)}")

        if update.callback_query:
            if update.callback_query.data.startswith(VB_CALLBACK_PREFIX):
                return await handle_callback(update, context)
            else:
                logger.info(f"Callback not for view_booking, skipping: {update.callback_query.data}")
                return
        elif update.message:
            return await handle_message(update, context)
        else:
            logger.error("Unknown update type in view_booking_handler")

    except Exception as e:
        logger.error(f"Error in view_booking_handler: {e}", exc_info=True)
        error_message = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞"
        await send_reply(update, error_message)


async def handle_message(update, context):
    try:
        if 'step' not in context.user_data or context.user_data['step'] == 1:
            await show_file_selection(update, context)
            context.user_data['step'] = 2
        elif context.user_data['step'] == 2:
            selected_file = update.message.text.strip()
            await show_bookings(update, context, selected_file)
            del context.user_data['step']
    except Exception as e:
        logger.error(f"Error in handle_message: {e}", exc_info=True)


async def handle_callback(update, context):
    try:
        query = update.callback_query
        await query.answer()

        if query.data.startswith(VB_SHEET_SELECT):
            selected_file = query.data.replace(f"{VB_SHEET_SELECT}_", "")
            await show_bookings(update, context, selected_file)

        try:
            await query.message.delete()
        except Exception as e:
            logger.warning(f"Could not delete message: {e}")

        if 'step' in context.user_data:
            del context.user_data['step']

    except Exception as e:
        logger.error(f"Error in handle_callback: {e}", exc_info=True)


async def show_file_selection(update, context):
    try:
        csv_files = get_all_booking_files()
        if not csv_files:
            await send_reply(update, "üì≠ –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π –≤ –ø–∞–ø–∫–µ `booking/`")
            return

        logger.info(f"Available CSV files: {csv_files}")

        keyboard = []
        for file_name in csv_files:
            display_name = format_file_name(file_name)
            callback_data = f"{VB_SHEET_SELECT}_{file_name}"
            keyboard.append([InlineKeyboardButton(display_name, callback_data=callback_data)])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await send_reply(update, "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π:", reply_markup)

    except Exception as e:
        logger.error(f"Error in show_file_selection: {e}", exc_info=True)
        await send_reply(update, "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤")


def get_file_path(file_name: str) -> str:
    return str(BOOKING_DATA_DIR / file_name)


def load_bookings_from_csv(file_name: str):
    try:
        file_path = get_file_path(file_name)
        if not os.path.exists(file_path):
            logger.error(f"File not found: {file_path}")
            return None

        df = pd.read_csv(file_path, encoding='utf-8')
        df = df.fillna('')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫
        required_cols = {'–ó–∞–µ–∑–¥', '–í—ã–µ–∑–¥'}
        if not required_cols.issubset(df.columns):
            logger.error(f"Missing required columns in {file_name}. Found: {df.columns.tolist()}")
            return None

        df['–ó–∞–µ–∑–¥'] = pd.to_datetime(df['–ó–∞–µ–∑–¥'], format='%d.%m.%Y', errors='coerce')
        df['–í—ã–µ–∑–¥'] = pd.to_datetime(df['–í—ã–µ–∑–¥'], format='%d.%m.%Y', errors='coerce')
        df = df.dropna(subset=['–ó–∞–µ–∑–¥', '–í—ã–µ–∑–¥'])

        return df
    except Exception as e:
        logger.error(f"Error loading CSV file {file_name}: {e}", exc_info=True)
        return None


async def show_bookings(update, context, file_name: str):
    try:
        csv_files = get_all_booking_files()
        if file_name not in csv_files:
            await send_reply(update, f"‚ùå –§–∞–π–ª {file_name} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–∞–ø–∫–µ `booking/`")
            return

        df = load_bookings_from_csv(file_name)
        if df is None:
            await send_reply(update, f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ {file_name}")
            return

        if df.empty:
            await send_reply(update, f"üì≠ –§–∞–π–ª {file_name} –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö")
            return

        today = date.today()
        active_bookings = df[df['–í—ã–µ–∑–¥'].dt.date >= today].copy()
        active_bookings = active_bookings.sort_values('–ó–∞–µ–∑–¥')

        if active_bookings.empty:
            await send_reply(update, f"üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π –≤ —Ñ–∞–π–ª–µ {format_file_name(file_name)}")
            return

        messages = prepare_booking_messages(file_name, active_bookings)
        for msg in messages:
            await send_reply(update, msg, parse_mode='HTML')

    except Exception as e:
        logger.error(f"Error in show_bookings: {e}", exc_info=True)
        await send_reply(update, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è—Ö")


def format_date(dt):
    if hasattr(dt, 'strftime'):
        return dt.strftime("%d.%m.%Y")
    return str(dt)


def prepare_booking_messages(file_name: str, bookings_df):
    messages = []
    display_file_name = format_file_name(file_name)
    current_message = f"<b>üìÖ –ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–∞ {display_file_name}:</b>\n\n"

    bookings = bookings_df.to_dict('records')
    for i, booking in enumerate(bookings):
        guest = booking.get('–ì–æ—Å—Ç—å', '–ù–µ —É–∫–∞–∑–∞–Ω')
        check_in = booking.get('–ó–∞–µ–∑–¥')
        check_out = booking.get('–í—ã–µ–∑–¥')

        nights = (check_out - check_in).days if check_in and check_out else 0

        booking_info = (
            f"<b>üè† –ë—Ä–æ–Ω—å #{i + 1}</b>\n"
            f"<b>{guest}</b>\n"
            f"üìÖ {format_date(check_in)} - {format_date(check_out)}\n"
            f"üåô –ù–æ—á–µ–π: {nights}\n"
            f"üíµ –°—É–º–º–∞: {booking.get('–°—É–º–º–∞–ë–∞—Ç—Ç—ã', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')} –±–∞—Ç—Ç\n\n"
        )

        if len(current_message + booking_info) > 4000:
            messages.append(current_message)
            current_message = booking_info
        else:
            current_message += booking_info

        # –°–≤–æ–±–æ–¥–Ω—ã–µ –ø–µ—Ä–∏–æ–¥—ã
        if i < len(bookings) - 1:
            next_check_in = bookings[i + 1].get('–ó–∞–µ–∑–¥')
            if check_out and next_check_in and check_out != next_check_in:
                free_nights = (next_check_in - check_out).days
                if free_nights > 0:
                    free_period = (
                        f"üÜì –°–≤–æ–±–æ–¥–Ω–æ:\n"
                        f"üìÖ –° {format_date(check_out)} - –ü–æ {format_date(next_check_in)}\n"
                        f"üåô {free_nights} –Ω–æ—á–µ–π\n\n"
                    )
                    if len(current_message + free_period) > 4000:
                        messages.append(current_message)
                        current_message = free_period
                    else:
                        current_message += free_period

    messages.append(current_message)
    return messages


async def send_reply(update, text, reply_markup=None, parse_mode=None):
    try:
        if update.callback_query:
            return await update.callback_query.message.reply_text(
                text, reply_markup=reply_markup, parse_mode=parse_mode
            )
        elif update.message:
            return await update.message.reply_text(
                text, reply_markup=reply_markup, parse_mode=parse_mode
            )
    except Exception as e:
        logger.error(f"Error in send_reply: {e}", exc_info=True)